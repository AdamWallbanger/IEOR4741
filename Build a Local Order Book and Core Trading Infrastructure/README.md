There are three main parts of this project, MarketSnapshot keeps a sorted top-of-book (bids descending, asks ascending) using std::map<double, std::unique_ptr<PriceLevel>>, removing a level when its quantity hits zero; OrderManager tracks placed orders in std::map<int, std::unique_ptr<MyOrder>>, assigns IDs, and updates/removes orders on cancels and fills; and main.cpp streams a simple feed (BID/ASK/EXECUTION) to update the snapshot, apply a rule and log human-readable events like [Market], [Strategy], [Execution], and [Order] to output.log.
Memory safety comes from RAII and exclusive ownership: all heap objects are created with std::make_unique, stored in containers of std::unique_ptr, and freed automatically on eraseâ€”there is no raw new/delete, avoiding leaks, double frees, and use-after-free.
This question seems to be a one I do not know how to answer, but a general step is put all the code in the same folder, and put the sample_feed.txt in the cmake_build_debug, then run the main function.
Correctness is verified by watching the book reflect updates. For checks, enable AddressSanitizer via make clean && make ASAN=1 (or run Valgrind on Linux) and confirm no leaks or invalid accesses.
